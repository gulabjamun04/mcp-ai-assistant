"""Sidebar component: tools list, cache stats, server health, demo mode."""

from __future__ import annotations

import streamlit as st

from ui import api

# Map server names to icons for tool badges
_SERVER_ICONS: dict[str, str] = {
    "web_search": "ðŸ”",
    "note_manager": "ðŸ“",
    "doc_summarizer": "ðŸ“„",
    "calculator": "ðŸ§®",
}


def render() -> None:
    """Render the sidebar content."""
    with st.sidebar:
        st.header("MCP AI Assistant")
        _render_server_status()
        st.divider()
        _render_tools()
        st.divider()
        _render_cache_stats()
        st.divider()
        _render_actions()
        st.divider()
        _render_demo_mode()


def _render_server_status() -> None:
    """Show connection status for each MCP server."""
    st.subheader("Server Status")
    try:
        health = api.get_health()
        for server in health.get("servers", []):
            name = server["name"]
            healthy = server["status"] == "healthy"
            dot = "ðŸŸ¢" if healthy else "ðŸ”´"
            st.markdown(f"{dot} **{name}**")
    except Exception:
        st.warning("Cannot reach backend API")


def _render_tools() -> None:
    """Show available tools as expandable cards."""
    st.subheader("ðŸ”§ Available Tools")
    try:
        tools = api.get_tools()
        if not tools:
            st.info("No tools discovered yet.")
            return
        for tool in tools:
            icon = _SERVER_ICONS.get(tool["server"], "âš™ï¸")
            with st.expander(f"{icon} {tool['name']}"):
                st.markdown(tool["description"])
                st.caption(f"Server: {tool['server']}")
    except Exception:
        st.warning("Could not load tools.")


def _render_cache_stats() -> None:
    """Show cache hit rate and counts."""
    st.subheader("ðŸ“Š Cache Stats")
    try:
        stats = api.get_cache_stats()
        hit_rate = stats.get("hit_rate", 0.0)
        hits = stats.get("hits", 0)
        misses = stats.get("misses", 0)
        keys = stats.get("total_keys", 0)

        st.progress(hit_rate, text=f"Hit rate: {hit_rate:.0%}")
        col1, col2, col3 = st.columns(3)
        col1.metric("Hits", hits)
        col2.metric("Misses", misses)
        col3.metric("Keys", keys)
    except Exception:
        st.warning("Cache stats unavailable.")


def _render_actions() -> None:
    """Refresh tools and clear cache buttons."""
    col1, col2 = st.columns(2)

    with col1:
        if st.button("ðŸ”„ Refresh Tools", use_container_width=True):
            try:
                result = api.refresh_tools()
                changes = result.get("changes", {})
                added = len(changes.get("added", []))
                removed = len(changes.get("removed", []))
                st.toast(f"Tools refreshed: +{added} / -{removed}")
                st.rerun()
            except Exception as e:
                st.error(f"Refresh failed: {e}")

    with col2:
        if st.button("ðŸ—‘ï¸ Clear Cache", use_container_width=True):
            try:
                result = api.clear_cache()
                cleared = result.get("cleared", 0)
                st.toast(f"Cache cleared: {cleared} keys removed")
                st.rerun()
            except Exception as e:
                st.error(f"Clear failed: {e}")


def _render_demo_mode() -> None:
    """Demo mode toggle for screen recordings and portfolio demos."""
    st.subheader("ðŸŽ¬ Demo Mode")
    st.caption("Auto-run preset queries for screen recordings")

    # Initialize toggle state BEFORE the widget is created.
    if "demo_toggle" not in st.session_state:
        st.session_state.demo_toggle = False

    # If chat.py signalled the demo just finished, flip the toggle
    # off BEFORE the widget renders (the only safe time to do so).
    if st.session_state.pop("_demo_finished", False):
        st.session_state.demo_toggle = False

    was_active = st.session_state.get("demo_active", False)
    demo_on = st.toggle("Enable", key="demo_toggle")

    if demo_on and not was_active:
        # Just toggled ON â€” start a fresh demo
        st.session_state.demo_active = True
        st.session_state.demo_index = 0
        st.session_state.messages = []
        st.session_state.pop("session_id", None)  # regenerated by chat
        st.rerun()
    elif not demo_on and was_active:
        # Just toggled OFF â€” stop demo
        st.session_state.demo_active = False
